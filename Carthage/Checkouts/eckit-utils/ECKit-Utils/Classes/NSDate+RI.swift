//
//  NSDate+RI.swift
//  RakutenIchiba
//
//  Created by Kerdkokaew, Peera on 6/8/16.
//  Copyright © 2016 Rakuten, Inc. All rights reserved.
//

import SwiftyJSON

public extension Date {
    
    public enum FallbackDate {
        case distantPast, now, distantFuture
    }
    
    public enum TimeZone {
        case local, utc
    }
    
    public enum Format: String {
        // For date formats, please refer to following link:
        // http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
        case YMD                = "yyyy-MM-dd"
        case YMD_SPACE_SPLASH   = "yyyy / MM / dd"
        case YMD_SLASH          = "yyyy/MM/dd"
        case YMD_HM_SLASH       = "yyyy/MM/dd HH:mm"
        case YSMD_HM_SLASH      = "yyyy/M/dd HH:mm"
        case YMD_HM             = "yyyy-MM-dd HH:mm"
        case YMD_HMS            = "yyyy-MM-dd HH:mm:ss"
        case YMD_T_HMS          = "yyyy-MM-dd'T'HH:mm:ss"
        case YMD_T_HMS_Z        = "yyyy-MM-dd'T'HH:mm:ss'Z'"
        case YMD_T_HMS_TZ       = "yyyy-MM-dd'T'HH:mm:ssZZZZZ"
        case YMD_T_HMS_ms_TZ    = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ"
        case YMD_T_HMS_X        = "yyyy-MM-dd'T'HH:mm:ssX"
        case E_DMY_HMS_X        = "EEE, dd MMM yyyy HH:mm:ss X"
        case JapaneseLocale     = "yyyy年MM月dd日"
        case JPN_MD             = "M月dd日"
        case MD_HM_JPN          = "M月d日 HH:mm"
        
        public func string(from date: Date) -> String {
            let formatter = Date.ri_formatter(self.rawValue)
            return formatter.string(from: date)
        }
        
        public func dateFromString(_ date: String) -> Date? {
            let formatter = Date.ri_formatter(self.rawValue)
            return formatter.date(from: date)
        }
        
        public func date(from json: JSON, key: String, fallback: FallbackDate = .now) -> Date {
            return date(from:json[key].stringValue, fallback: fallback)
        }
        
        public func date(from dateString: String, fallback: FallbackDate = .now) -> Date {
            if let newDate = dateFromString(dateString) {
                return newDate
            } else {
                switch fallback {
                case .now:
                    return Date()
                case .distantFuture:
                    return Date.distantFuture
                case .distantPast:
                    return Date.distantPast
                }
            }
        }
    }
    
    // MARK: - Helpers
    
    // Components
    private static func ri_componentFlags() -> Set<Calendar.Component> { return [Calendar.Component.year, Calendar.Component.month, Calendar.Component.day, Calendar.Component.weekOfYear, Calendar.Component.hour, Calendar.Component.minute, Calendar.Component.second, Calendar.Component.weekday, Calendar.Component.weekdayOrdinal, Calendar.Component.weekOfYear] }
    
    private func ri_components() -> DateComponents {
        return Calendar.current.dateComponents(Date.ri_componentFlags(), from: self)
    }
    
    /**
     Creates a new date from the start of the day.
     
     - Returns A new date object.
     */
    public func ri_dateAtStartOfDay() -> Date {
        var components = self.ri_components()
        components.hour = 0
        components.minute = 0
        components.second = 0
        return Calendar.current.date(from: components)!
    }
    
    public func ri_between(_ beginDate: Date, endDate: Date) -> Bool {
        return self.compare(beginDate) != .orderedAscending && self.compare(endDate) != .orderedDescending
    }
    
    public func ri_before(_ compareDate: Date) -> Bool {
        return self.compare(compareDate) == .orderedAscending
    }
    
    public func ri_after(_ compareDate: Date) -> Bool {
        return self.compare(compareDate) == .orderedDescending
    }
    
    public func ri_distance(from compareDate: Date) -> TimeInterval {
        return self.timeIntervalSinceNow - compareDate.timeIntervalSinceNow
    }
    
    public static func ri_timeInteval(days: Int) -> TimeInterval {
        return TimeInterval(days) * ri_timeInterval(hours: 24)
    }
    
    public static func ri_timeInterval(hours: Int) -> TimeInterval {
        return TimeInterval(hours) * ri_timeInterval(seconds: 60)
    }
    
    public static func ri_timeInterval(seconds: Int) -> TimeInterval {
        return TimeInterval(seconds) * 60
    }
    
    /**
     Returns a cached static array of NSDateFormatters so that thy are only created once.
     */
    private static var sharedDateFormatters: [String: DateFormatter] = [String: DateFormatter]()
    
    /**
     Returns a cached formatter based on the format, timeZone and locale. Formatters are cached in a singleton array using hashkeys generated by format, timeZone and locale.
     
     - important
     should use default timeZone and locale or maybe fail to convert date(String).
     refer to link for detail.
     'Working With Fixed Format Date Representations'
     https://developer.apple.com/reference/foundation/dateformatter
     
     - Parameter format: The format to use.
     - Parameter timeZone: The time zone to use, defaults to the UTC.
     - Parameter locale: The locale to use, defaults to the "en_US_POSIX".
     - Returns: The date formatter.
     */
    private static func ri_formatter(_ format: String = Format.YMD_T_HMS_TZ.rawValue,
                                     timeZone: Foundation.TimeZone? = Foundation.TimeZone.current,
                                     locale: Locale = Locale(identifier: "en_US_POSIX")) -> DateFormatter {
        let hashKey = "\(format.hashValue)\(String(describing: timeZone?.hashValue))\(locale.hashValue)"
        var formatters = Date.sharedDateFormatters
        if let cachedDateFormatter = formatters[hashKey] {
            return cachedDateFormatter
        } else {
            let formatter = DateFormatter()
            formatter.dateFormat = format
            formatter.timeZone = timeZone
            formatter.calendar = Calendar(identifier: Calendar.Identifier.gregorian)
            formatter.locale = locale
            Date.sharedDateFormatters[hashKey] = formatter
            return formatter
        }
    }    
}
